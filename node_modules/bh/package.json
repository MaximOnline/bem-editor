{
  "author": {
    "name": "Marat Dulin",
    "email": "mdevils@yandex.ru"
  },
  "description": "Template engine. BEMJSON -> HTML processor.",
  "name": "bh",
  "version": "3.1.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/enb-make/bh"
  },
  "licence": "MIT",
  "contributors": [
    {
      "name": "Marat Dulin",
      "email": "mdevils@yandex.ru"
    },
    {
      "name": "Dmitry Filatov",
      "email": "dfilatov@yandex-team.ru"
    },
    {
      "name": "Mikhail Troshev",
      "email": "mishanga@yandex-team.ru"
    }
  ],
  "devDependencies": {
    "mocha": "1.x",
    "chai": "1.x",
    "istanbul": "0.3.x",
    "jshint": "2.x",
    "jscs": "1.5.x"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "scripts": {
    "test": "npm run-script jshint && npm run-script check-style && npm run-script unit-test-coverage",
    "jshint": "jshint .",
    "unit-test": "mocha -u bdd -R spec --recursive test",
    "unit-test-coverage": "istanbul cover ./node_modules/mocha/bin/_mocha -- -u bdd -R spec --recursive test",
    "check-style": "./node_modules/jscs/bin/jscs ."
  },
  "readme": "BH [![NPM version](https://badge.fury.io/js/bh.svg)](http://badge.fury.io/js/bh) [![Build Status](https://travis-ci.org/enb-make/bh.svg?branch=master)](https://travis-ci.org/enb-make/bh) [![Dependency Status](https://gemnasium.com/enb-make/bh.svg)](https://gemnasium.com/enb-make/bh) [![Coverage Status](https://img.shields.io/coveralls/enb-make/bh.svg?branch=master)](https://coveralls.io/r/enb-make/bh)\n===\n\nBH — это BEMJSON-процессор, который превращает BEMJSON в HTML.\n\nПреимущества\n--------------------\n\n1. Быстрый.\n2. Не требует компиляции.\n3. Удобен в отладке, т.к. не компилируется в другой код.\n4. Написан на чистом JavaScript, используется и расширяется через JavaScript.\n5. Прост для понимания, т.к. это обертка над обычными преобразованиями исходного BEMJSON в конечный BEMJSON / HTML.\n6. Компактен на клиенте (12,5 Кб после сжатия, 3,5 Кб после gzip).\n\nУстановка\n---------\n\nBH-процессор можно найти в npm-пакете `bh`, а ENB-технологии для его использования — в npm-пакете `enb-bh`.\n\n```\nnpm install bh\n```\n\nИспользование\n-------------\n\nBH-файлы в проекте имеют суффикс `bh.js` (например, `page.bh.js`). Файл формируется в формате CommonJS для NodeJS:\n\n```javascript\nmodule.exports = function(bh) {\n    // ...\n};\n```\n\nДля преобразования исходного дерева BEMJSON в конечный HTML используется метод `apply`. Для получения промежуточного результата в виде развернутого BEMJSON-дерева нужно использовать метод `processBemJson`.\n\nПростой пример использования:\n```javascript\nvar bh = new (require('bh').BH);\nbh.match('button', function(ctx) {\n    ctx.tag('button');\n})\nbh.processBemJson({ block: 'button' }); // { block: 'button', mods: {}, tag: 'button' }\nbh.apply({ block: 'button' }); // '<button class=\"button\"></button>'\n```\n\nПреобразования\n--------------\n\nФункции для работы с BEMJSON — **шаблоны** — объявляются через метод `match`. В теле функций описывается логика преобразования BEMJSON.\nВ функцию-шаблон передаются два аргумента: `ctx` — инстанция класса `Ctx` и `json` — ссылка на текущий узел BEMJSON-дерева.\n\n*Замечание*: Категорически не рекомендуется вносить изменения напрямую в объект `json`. Вместо этого следует использовать методы объекта `ctx`. Объект `json` рекомендуется использовать только для «чтения» (см. также метод `ctx.json()`).\n\nСинтаксис:\n\n```javascript\n{BH} bh.match({String} expression, function({Ctx} ctx, {Object} json) {\n    //.. actions\n});\n```\n\nТакже допустимо объявлять несколько шаблонов в одном вызове метода `match`.\n\nСинтаксис:\n\n```javascript\n{BH} bh.match({Array} expressions, function({Ctx} ctx));\n\n```\n\nГде `expressions` — массив вида:\n\n```javascript\n[\n    {String} expression1,\n    ...,\n\n    {String} expressionN\n]\n```\n\nИли в виде объекта:\n\n```javascript\n{BH} bh.match({Object} templates);\n\n```\n\nГде `templates` представляет собой объект вида:\n\n```javascript\n{\n    {String} expression1 : function({Ctx} ctx) {\n        //.. actions1\n    },\n\n    ...,\n\n    {String} expressionN : function({Ctx} ctx) {\n        //.. actionsN\n    },\n}\n```\n\nНиже в этом документе можно найти перечень методов класса `Ctx`. Дальше пойдем по примерам.\n\nНапример, зададим блоку `button` тег `button`, а блоку `input` тег `input`:\n\n```javascript\nbh.match('button', function(ctx) {\n    ctx.tag('button');\n});\nbh.match('input', function(ctx) {\n    ctx.tag('input');\n});\n```\n\nТеперь нам нужна псевдо-кнопка. То есть, если у кнопки модификатор `pseudo` равен `yes`, то нужен тег `a` и атрибут `role=\"button\"`:\n\n```javascript\nbh.match('button_pseudo_yes', function(ctx) {\n    ctx\n        .tag('a')\n        .attr('role', 'button');\n});\n```\n\nВ данном примере мы матчимся не просто на блок `button`, а на блок `button` с модификатором `pseudo`, имеющим значение `yes`.\n\nМатчинг\n-------\n\nРассмотрим синтаксис строки матчинга для функций преобразования (в квадратных скобках указаны необязательные параметры):\n\n```javascript\n'block[_blockModName[_blockModVal]][__elemName][_elemModName[_elemModVal]]'\n```\n\nПо-русски:\n\n```javascript\n'блок[_имяМодификатораБлока[_значениеМодификатораБлока]][__имяЭлемента][_имяМодификатораЭлемента[_значениеМодификатораЭлемента]]'\n```\n\nДополнительные примеры\n-----------\n\nНапример, мы хотим установить модификатор `state` со значением `closed` для всех блоков `popup`:\n\n```javascript\nbh.match('popup', function(ctx) {\n    ctx.mod('state', 'closed');\n});\n```\n\nЗамиксуем `form` в `search-form`:\n\n```javascript\nbh.match('search-form', function(ctx) {\n    ctx.mix({ block: 'form' });\n});\n```\n\nУстановим класс для `page`:\n\n```javascript\nbh.match('page', function(ctx) {\n    ctx.cls('ua_js_no ua_css_standard');\n});\n```\n\nПреобразование BEMJSON-дерева\n-----------------------------\n\nКроме модификации элемента, функция-преобразователь может вернуть новый BEMJSON. Здесь мы воспользуемся методами `ctx.json()` (возвращает текущий элемент BEMJSON «как есть») и `ctx.content()` (возвращает или устанавливает контент).\n\nНапример, обернем блок `header` блоком `header-wrapper`:\n\n```javascript\nbh.match('header', function(ctx) {\n    return {\n        block: 'header-wrapper',\n        content: ctx.json()\n    };\n});\n```\n\nОбернем содержимое `button` элементом `content`:\n\n```javascript\nbh.match('button', function(ctx) {\n    ctx.content({\n        elem: 'content',\n        content: ctx.content()\n    }, true);\n});\n```\n\nМетод `ctx.content` принимает первым аргументом BEMJSON, который надо выставить для содержимого, а вторым — флаг force (выставить содержимое, даже если оно уже существует).\n\nДобавим элемент `before` в начало, а `after` — в конец содержимого блока `header`:\n\n```javascript\nbh.match('header', function(ctx) {\n    ctx.content([\n        { elem: 'before' },\n        ctx.content(),\n        { elem: 'after' }\n    ], true);\n});\n```\n\nДобавим блок `before-button` перед блоком `button`:\n\n```javascript\nbh.match('button', function(ctx) {\n    return [\n        { block: 'before-button' },\n        ctx.json()\n    ];\n});\n```\n\n\nКласс Ctx\n=========\n\nИнстанции класса `Ctx` передаются во все шаблоны. Все методы класса в set-режиме возвращают инстанцию класса, то есть реализут чейнинг.\n\nРассмотрим методы класса:\n\nctx.tag([value[, force]])\n------------------------\n\nВозвращает/устанавливает тег в зависимости от аргументов. **force** — задать значение тега, даже если оно было задано ранее.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.tag('input');\n});\n```\n\n*Замечание*: Если передать в качестве значения `false` или пустую строку, текущий узел не будет выведен в конечный HTML, выведется только его содержимое, если оно есть.\n\nctx.mod(key[, value[, force]])\n------------------------\n\nВозвращает/устанавливает модификатор в зависимости от аргументов. **force** — задать модификатор, даже если он был задан ранее.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.mod('native', 'yes');\n    ctx.mod('disabled', true);\n});\n\nbh.match('input_islands_yes', function(ctx) {\n    ctx.mod('native', '', true);\n    ctx.mod('disabled', false, true);\n});\n```\n\nctx.mods([values[, force]])\n---------------------------\n\nВозвращает/устанавливает модификаторы в зависимости от аргументов. **force** — задать модификаторы, даже если они были заданы ранее.\n\n```javascript\nbh.match('paranja', function(ctx) {\n    ctx.mods({\n        theme: 'normal',\n        disabled: true\n    });\n});\n```\n\nctx.attr(key[, value[, force]])\n------------------------\n\nВозвращает/устанавливает значение атрибута в зависимости от аргументов. **force** — задать значение атрибута, даже если оно было задано ранее.\n\n```javascript\nbh.match('input_disabled_yes', function(ctx) {\n    ctx.attr('disabled', 'disabled');\n});\n```\n\n*Замечание*: Если необходимо удалить сам атрибут, а не просто обнулить значение атрибута, то вторым параметром надо передать `null`:\n\n```javascript\nbh.match('link', function(ctx) {\n    ctx.attr('href', null);\n});\n```\n\nctx.attrs([values[, force]])\n---------------------------\n\nВозвращает/устанавливает атрибуты в зависимости от аргументов. **force** — задать атрибуты, даже если они были заданы ранее.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.attrs({\n        name: ctx.param('name'),\n        autocomplete: 'off'\n    });\n});\n```\n\nctx.mix([value[, force]])\n------------------------\n\nВозвращает/устанавливает значение mix в зависимости от аргументов.\n\nПри установке значения если **force** равен **true**, то переданный микс заменяет прежнее значение, в противном случае миксы складываются.\n\n```javascript\nbh.match('button_pseudo_yes', function(ctx) {\n    ctx.mix({ block: 'link', mods: { pseudo: 'yes' } });\n    ctx.mix([\n        { elem: 'text' },\n        { block: 'ajax' }\n    ]);\n});\n```\n\nctx.bem([value[, force]])\n------------------------\n\nВозвращает/устанавливает значение bem в зависимости от аргументов. **force** — задать значение bem, даже если оно было задано ранее.\n\nЕсли bem имеет значение **false**, то для элемента не будут генерироваться БЭМ-классы.\n\n```javascript\nbh.match('meta', function(ctx) {\n    ctx.bem(false);\n});\n```\n\nctx.js([value[, force]])\n------------------------\n\nВозвращает/устанавливает значение js в зависимости от аргументов. **force** — задать значение js, даже если оно было задано ранее.\n\nЗначение js используется для инициализации блоков в браузере через `BEM.DOM.init()`.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.js(true);\n});\n```\n\nctx.content([value[, force]])\n-----------------------------\n\nВозвращает/устанавливает содержимое в зависимости от аргументов. **force** — задать содержимое, даже если оно было задано ранее.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.content({ elem: 'control' });\n});\n```\n\nctx.json()\n----------\n\nВозвращает текущий фрагмент BEMJSON-дерева. Может использоваться в связке с `return` для враппинга и подобных целей. Для сокращения можно использовать второй аргумент функции-шаблона — `json`.\n\n*Замечание*: После вызова `ctx.applyBase()` нарушается цепочка естественного применения шаблонов. Из-за этого `json` перестает указывать на актуальный узел в BEMJSON-дереве. В этом случае следует использовать `ctx.json()`.\n\n```javascript\nbh.match('input', function(ctx, json) {\n    return {\n        elem: 'wrapper',\n        attrs: { name: json.name },\n        content: ctx.json()\n    };\n});\n```\n\nctx.position()\n--------------\nctx.isFirst()\n-------------\nctx.isLast()\n------------\n\n**ctx.position()** возвращает позицию текущего BEMJSON-элемента в рамках родительского.\n**ctx.isFirst()** возвращает true, если текущий BEMJSON-элемент — первый в рамках родительского BEMJSON-элемента.\n**ctx.isLast()** возвращает true, если текущий BEMJSON-элемент — последний в рамках родительского BEMJSON-элемента.\n\nПример:\n```javascript\nbh.match('list__item', function(ctx) {\n    ctx.mod('pos', ctx.position());\n    if (ctx.isFirst()) {\n        ctx.mod('first', 'yes');\n    }\n    if (ctx.isLast()) {\n        ctx.mod('last', 'yes');\n    }\n});\n```\n\nctx.isSimple()\n------------\n\nПроверяет, что объект является примитивом.\n```javascript\nbh.match('link', function(ctx) {\n    ctx.tag(ctx.isSimple(ctx.content()) ? 'span' : 'div');\n});\n```\n\nctx.extend()\n------------\n\nАналог функции `extend` в jQuery.\n\nctx.applyBase()\n---------------\n\nВыполняет преобразования данного BEMJSON-элемента остальными шаблонами. Может понадобиться, например, чтобы добавить элемент в самый конец содержимого, если в базовых шаблонах в конец содержимого добавляются другие элементы.\n\nПример:\n\n```javascript\nbh.match('header', function(ctx) {\n   ctx.content([\n       ctx.content(),\n       { elem: 'under' }\n   ], true);\n});\n\nbh.match('header_float_yes', function(ctx) {\n   ctx.applyBase();\n   ctx.content([\n       ctx.content(),\n       { elem: 'clear' }\n   ], true);\n});\n```\n\nctx.stop()\n----------\n\nОстанавливает выполнение прочих шаблонов для данного BEMJSON-элемента.\n\nПример:\n\n```javascript\nbh.match('button', function(ctx) {\n    ctx.tag('button', true);\n});\nbh.match('button', function(ctx) {\n    ctx.tag('span');\n    ctx.stop();\n});\n```\n\nctx.generateId()\n----------------\n\nВозвращает уникальный идентификатор. Может использоваться, например, чтобы задать соответствие между `label` и `input`.\n\nctx.param(key[, value[, force]])\n--------------------------------\n\nВозвращает/устанавливает параметр текущего BEMJSON-элемента. **force** — задать значение параметра, даже если оно было задано ранее. Например:\n\n```javascript\nbh.match('search', function(ctx) {\n    ctx.attr('action', ctx.param('action') || '/');\n});\n```\n\nctx.tParam(key[, value])\n------------------------\n\nПередает параметр вглубь BEMJSON-дерева. **force** — задать значение параметра, даже если оно было задано ранее.\n\n```javascript\nbh.match('input', function(ctx) {\n    ctx.content({ elem: 'control' });\n    ctx.tParam('value', ctx.param('value'));\n});\n\nbh.match('input__control', function(ctx) {\n    ctx.attr('value', ctx.tParam('value'));\n});\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/enb-make/bh/issues"
  },
  "homepage": "https://github.com/enb-make/bh",
  "_id": "bh@3.1.1",
  "_shasum": "505e504de595f11064d5861c2240c29f8d24180b",
  "_from": "bh@>= 1.0.0 < 4.0.0",
  "_resolved": "https://registry.npmjs.org/bh/-/bh-3.1.1.tgz"
}
